DTO(数据传输对象层)，该层负责屏蔽后端的实体层，将UI层需要的数据进行重新的定义和封装，
在实际的业务场景下，后端实现或存储的数据远比用户需要的数据要庞大和复杂，所以前端需要的数据相对来说要么是组合的，要么是抽取的，不是完整的，
因为我们在设计数据存储格式上都会有一些额外的设计和考虑。
 前端的UI层，只是知道DTO的存在，同时前端需要的数据都在一个DTO中，这样，每次调用服务层的时候，
 只需要调用一次就可以完成所有的业务逻辑操作，而不是原来的直接调用业务逻辑层那样的，需要调用多次，
 对于分布式场景下，减少服务调用的次数，尤其重要。
 
数据传输对象介绍
　　数据传输对象，即Data Transfer Object，简称DTO。

　　一个为了减少方法调用次数而在进程间传输数据的对象，《企业应用架构模式》如是说。

　　可以看出，DTO用于分布式环境，主要用来解决分布式调用的性能问题。同一进程内的对象调用，速度是非常快的，但跨进程调用，甚至跨网络调用，性能下降N个数量级。为了提升性能，需要减少调用次数，这就要求把多次调用的结果打包成一个对象，在一次调用中返回尽量多的数据。

　　上面是DTO的原始含义，下面来看看我的山寨用法。

　　虽然我也取名为DTO，但我的动机并不完全是一次打包更多数据来提升性能，而是解决上面提到的几个问题，当然它们之间有一定关系，可以看作一种变种用法。

DTO的长相

　　DTO是一个贫血对象，也就是它里面基本没有方法，只有一堆属性，并且所有属性都具有public的getter和setter访问器。

　　DTO拥有public的setter访问器，方便的解决了表现层的模型绑定问题。

　　由于DTO不执行业务操作，仅用于传递数据，所以不应该定义非常复杂的对象引用关系，这样就避免了循环引用，解决了对象序列化的问题。

DTO的粒度

　　DTO可以根据应用需求定义成不同的粒度，在一般情况下，DTO是聚合粒度，也就是说，一个领域层的聚合对应一个DTO，这样做的一个好处是方便对CRUD操作进行抽象以及代码生成。

　　界面如果想保持简单，应该尽量一个界面操作一个聚合，将聚合的数据映射到DTO后，传给视图展示。

　　对于更加复杂的界面，需要在一个界面操作多个聚合，这种情况下，把需要的全部数据打包到DTO进行操作。

　　从以上介绍中，你应该了解DTO不能理解为单表操作，它可以包含你需要的全部数据。

DTO的位置

　　DTO处于应用层，在表现层与领域层之间传递数据。

　　DTO由应用层服务使用，应用层服务从仓储中获得聚合，并调用DTO转换器将聚合映射为DTO，再将DTO传递给表现层。

　　关于应用层服务，后续再专门介绍。

DTO的映射

　　聚合与DTO的转换，看上去是一个简单问题，在聚合与DTO几乎完全一致的情况下，采用映射组件将非常省力。很多人采用AutoMapper，但它的性能稍微差了点，EmitMapper是更好的选择，性能接近硬编码。

　　当DTO与聚合显著不同时，我发现手工编码更加清晰高效。我采用代码生成器创建出一个代码基础，在有个性化需求时，手工修改映射代码。